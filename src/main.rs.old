use anyhow::{Context, Result};
use eframe::{egui, App};
use std::path::PathBuf;
use std::process::{Command, Stdio};
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::{Instant, Duration};
use std::io::{BufRead, BufReader, Read, Seek, SeekFrom};
use std::fs::File;
use sha2::{Sha256, Digest};
use serde::Deserialize;

fn main() -> eframe::Result<()> {
    let options = eframe::NativeOptions {
        viewport: egui::ViewportBuilder::default()
            .with_inner_size([1000.0, 600.0])
            .with_min_inner_size([900.0, 550.0]),
        ..Default::default()
    };
    eframe::run_native(
        "FluxFlasher",
        options,
        Box::new(|cc| {
            cc.egui_ctx.set_visuals(egui::Visuals::dark());
            Box::new(FluxFlasher::default())
        }),
    )
}

#[derive(Clone, Debug)]
struct UsbDevice {
    path: String,
    size: String,
    size_bytes: u64,
    removable: bool,
    mounted: bool,
    is_system_disk: bool,
    mount_points: Vec<String>,
}

#[derive(Debug, Deserialize)]
struct LsblkOutput {
    blockdevices: Vec<LsblkDevice>,
}

#[derive(Debug, Deserialize)]
struct LsblkDevice {
    name: String,
    size: u64,
    #[serde(default)]
    rm: bool,
    #[serde(default)]
    ro: bool,
    #[serde(rename = "type")]
    dev_type: String,
    mountpoint: Option<String>,
    #[serde(default)]
    children: Vec<LsblkDevice>,
}

struct FluxFlasher {
    image_path: Option<PathBuf>,
    image_size: Option<u64>,
    devices: Vec<UsbDevice>,
    selected_device: Option<usize>,
    status: Arc<Mutex<String>>,
    progress: Arc<Mutex<f32>>,
    flashing: bool,
    show_device_modal: bool,
    show_settings_modal: bool,
    show_completion_modal: bool,
    show_confirmation_modal: bool,
    show_error_modal: bool,
    show_unmount_prompt: bool,
    error_message: String,
    error_details: String,
    flash_start_time: Option<Instant>,
    bytes_written: Arc<Mutex<u64>>,
    setting_report_errors: bool,
    setting_trim_space: bool,
    is_verifying: bool,
    verify_progress: Arc<Mutex<f32>>,
}

impl Default for FluxFlasher {
    fn default() -> Self {
        Self {
            image_path: None,
            image_size: None,
            devices: Vec::new(),
            selected_device: None,
            status: Arc::new(Mutex::new(String::new())),
            progress: Arc::new(Mutex::new(0.0)),
            flashing: false,
            show_device_modal: false,
            show_settings_modal: false,
            show_completion_modal: false,
            show_confirmation_modal: false,
            show_error_modal: false,
            show_unmount_prompt: false,
            error_message: String::new(),
            error_details: String::new(),
            flash_start_time: None,
            bytes_written: Arc::new(Mutex::new(0)),
            setting_report_errors: false,
            setting_trim_space: false,
            is_verifying: false,
            verify_progress: Arc::new(Mutex::new(0.0)),
        }
    }
}

const BG_DARK: egui::Color32 = egui::Color32::from_rgb(47, 50, 53);
const BG_MEDIUM: egui::Color32 = egui::Color32::from_rgb(71, 75, 79);
const CARD_BG: egui::Color32 = egui::Color32::from_rgb(60, 63, 67);
const ACCENT_CYAN: egui::Color32 = egui::Color32::from_rgb(0, 174, 239);
const SUCCESS_GREEN: egui::Color32 = egui::Color32::from_rgb(76, 175, 80);
const DISABLED_GREY: egui::Color32 = egui::Color32::from_rgb(100, 100, 110);
const TEXT_WHITE: egui::Color32 = egui::Color32::WHITE;
const TEXT_GREY: egui::Color32 = egui::Color32::from_rgb(160, 160, 170);

impl App for FluxFlasher {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        if self.devices.is_empty() && !self.flashing {
            if let Ok(devices) = list_usb_devices() {
                self.devices = devices;
            }
        }

        // Check if flashing completed (and verification)
        // We consider it done if status contains success or error, or handled via flags.
        // Simplified: if progress is 1.0 depending on state.
        // Actually, best to check the status message or a shared atomic.
        // But for this simple app, we can check if both progresses are done.
        
        // Wait, start_flash spawns a thread. The thread updates status.
        // If status says "All operations completed successfully!", we are done.
        let status_text = self.status.lock().unwrap().clone();
        if self.flashing {
             if status_text == "All operations completed successfully!" {
                 self.flashing = false;
                 self.show_completion_modal = true;
             } else if status_text.contains("Error") {
                 // Handle error state -> stop flashing flag, show error
                 self.flashing = false;
                 self.error_message = "Operation Failed".to_string();
                 self.error_details = status_text.clone();
                 self.show_error_modal = true;
             }
             
             // Check if we shifted to verification
             if status_text.contains("Verifying") {
                  self.is_verifying = true;
             }
        }
        
        let frame = egui::Frame::central_panel(&ctx.style()).fill(BG_MEDIUM);

        egui::CentralPanel::default().frame(frame).show(ctx, |ui| {
            egui::TopBottomPanel::top("top_bar")
                .frame(egui::Frame::none().fill(BG_DARK).inner_margin(12.0))
                .show_inside(ui, |ui| {
                    ui.horizontal(|ui| {
                        ui.label(egui::RichText::new("⚡ FluxFlasher").size(18.0).color(TEXT_WHITE).strong());
                        ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                            if ui.button(egui::RichText::new("❓").size(16.0)).clicked() {}
                            ui.add_space(5.0);
                            if ui.button(egui::RichText::new("⚙").size(16.0)).clicked() {
                                self.show_settings_modal = true;
                            }
                        });
                    });
                });

            if self.flashing {
                self.render_progress_fullscreen(ui);
            } else {
                ui.add_space(40.0);
                ui.vertical_centered(|ui| {
                    egui::ScrollArea::horizontal().show(ui, |ui| {
                        ui.horizontal(|ui| {
                            let step_width = 280.0;
                            self.render_step_card_1(ui, step_width);
                            ui.add_space(8.0);
                            ui.add_space(0.0);
                            ui.label(egui::RichText::new(">").size(24.0).color(TEXT_GREY));
                            ui.add_space(8.0);
                            self.render_step_card_2(ui, step_width);
                            ui.add_space(8.0);
                            ui.label(egui::RichText::new(">").size(24.0).color(TEXT_GREY));
                            ui.add_space(8.0);
                            self.render_step_card_3(ui, step_width);
                        });
                    });
                });
            }
        });

        if self.show_device_modal {
            self.render_device_modal(ctx);
        }
        if self.show_settings_modal {
            self.render_settings_modal(ctx);
        }
        if self.show_completion_modal {
            self.render_completion_modal(ctx);
        }
        if self.show_confirmation_modal {
            self.render_confirmation_modal(ctx);
        }
        if self.show_error_modal {
            self.render_error_modal(ctx);
        }
        if self.show_unmount_prompt {
            self.render_unmount_prompt(ctx);
        }

        ctx.request_repaint();
    }
}

impl FluxFlasher {
    fn render_step_card_1(&mut self, ui: &mut egui::Ui, width: f32) {
        let is_complete = self.image_path.is_some();
        egui::Frame::none()
            .fill(CARD_BG)
            .stroke(egui::Stroke::new(2.0, if is_complete { SUCCESS_GREEN } else { DISABLED_GREY }))
            .rounding(8.0)
            .inner_margin(20.0)
            .show(ui, |ui| {
                ui.set_width(width);
                ui.set_height(200.0);
                ui.vertical_centered(|ui| {
                    ui.label(egui::RichText::new("1").size(32.0).color(TEXT_GREY).strong());
                    ui.label(egui::RichText::new("Select Image").size(16.0).color(TEXT_WHITE));
                    ui.add_space(15.0);
                    if let Some(path) = &self.image_path {
                        ui.label(egui::RichText::new(path.file_name().unwrap().to_string_lossy()).size(14.0).color(TEXT_WHITE));
                        if let Some(size) = self.image_size {
                            ui.label(egui::RichText::new(format_size(size)).size(12.0).color(TEXT_GREY));
                        }
                        ui.add_space(10.0);
                        if !self.flashing && ui.button(egui::RichText::new("Change").size(12.0).color(ACCENT_CYAN)).clicked() {
                            if let Some(new_path) = rfd::FileDialog::new().add_filter("Disk Images", &["iso", "img"]).pick_file() {
                                self.image_size = std::fs::metadata(&new_path).ok().map(|m| m.len());
                                self.image_path = Some(new_path);
                            }
                        }
                        ui.add_space(5.0);
                        ui.label(egui::RichText::new("✓ Ready").size(12.0).color(SUCCESS_GREEN));
                    } else {
                        let button = egui::Button::new(egui::RichText::new("Select Image").size(14.0).color(TEXT_WHITE))
                            .fill(ACCENT_CYAN).rounding(20.0).min_size(egui::vec2(180.0, 40.0));
                        if ui.add_enabled(!self.flashing, button).clicked() {
                            if let Some(path) = rfd::FileDialog::new().add_filter("Disk Images", &["iso", "img"]).pick_file() {
                                self.image_size = std::fs::metadata(&path).ok().map(|m| m.len());
                                self.image_path = Some(path);
                            }
                        }
                    }
                });
            });
    }

    fn render_step_card_2(&mut self, ui: &mut egui::Ui, width: f32) {
        let is_complete = self.selected_device.is_some();
        egui::Frame::none()
            .fill(CARD_BG)
            .stroke(egui::Stroke::new(2.0, if is_complete { SUCCESS_GREEN } else { DISABLED_GREY }))
            .rounding(8.0)
            .inner_margin(20.0)
            .show(ui, |ui| {
                ui.set_width(width);
                ui.set_height(200.0);
                ui.vertical_centered(|ui| {
                    ui.label(egui::RichText::new("2").size(32.0).color(TEXT_GREY).strong());
                    ui.label(egui::RichText::new("Select Target").size(16.0).color(TEXT_WHITE));
                    ui.add_space(15.0);
                    let device_info = self.selected_device.and_then(|idx| {
                        self.devices.get(idx).map(|d| (d.path.clone(), d.size.clone()))
                    });
                    if let Some((path, size)) = device_info {
                        ui.label(egui::RichText::new(&path).size(14.0).color(TEXT_WHITE));
                        ui.label(egui::RichText::new(&size).size(12.0).color(TEXT_GREY));
                        ui.add_space(10.0);
                        if !self.flashing && ui.button(egui::RichText::new("Change").size(12.0).color(ACCENT_CYAN)).clicked() {
                            if let Ok(devices) = list_usb_devices() {
                                self.devices = devices;
                            }
                            self.show_device_modal = true;
                        }
                        ui.add_space(5.0);
                        ui.label(egui::RichText::new("✓ Ready").size(12.0).color(SUCCESS_GREEN));
                    } else {
                        let button = egui::Button::new(egui::RichText::new("Select USB").size(14.0).color(TEXT_WHITE))
                            .fill(ACCENT_CYAN).rounding(20.0).min_size(egui::vec2(180.0, 40.0));
                        if ui.add_enabled(!self.flashing, button).clicked() {
                            if let Ok(devices) = list_usb_devices() {
                                self.devices = devices;
                            }
                            self.show_device_modal = true;
                        }
                    }
                });
            });
    }

    fn render_step_card_3(&mut self, ui: &mut egui::Ui, width: f32) {
        let can_flash = self.image_path.is_some() && self.selected_device.is_some();
        egui::Frame::none()
            .fill(CARD_BG)
            .stroke(egui::Stroke::new(2.0, if can_flash { ACCENT_CYAN } else { DISABLED_GREY }))
            .rounding(8.0)
            .inner_margin(20.0)
            .show(ui, |ui| {
                ui.set_width(width);
                ui.set_height(200.0);
                ui.vertical_centered(|ui| {
                    ui.label(egui::RichText::new("3").size(32.0).color(TEXT_GREY).strong());
                    ui.label(egui::RichText::new("Flash!").size(16.0).color(TEXT_WHITE));
                    ui.add_space(30.0);
                    let button = egui::Button::new(egui::RichText::new("Flash!").size(18.0).strong().color(TEXT_WHITE))
                        .fill(if can_flash { ACCENT_CYAN } else { DISABLED_GREY })
                        .rounding(25.0).min_size(egui::vec2(200.0, 50.0));
                    if ui.add_enabled(can_flash && !self.flashing, button).clicked() {
                        if let (Some(img_path), Some(dev_idx)) = (self.image_path.clone(), self.selected_device) {
                            let device = &self.devices[dev_idx];
                            
                            // 1. Check size
                            if let Ok(metadata) = std::fs::metadata(&img_path) {
                                let img_size = metadata.len();
                                if img_size > device.size_bytes {
                                    self.error_message = "Target Device Too Small".to_string();
                                    self.error_details = format!(
                                        "Image size ({}) is larger than device capacity ({}).",
                                        format_size(img_size),
                                        format_size(device.size_bytes)
                                    );
                                    self.show_error_modal = true;
                                    return;
                                }
                            }
                            
                            // 2. Check if mounted - Logic moved to flash_image auto-unmount
                            // No need to prompt, we will unmount everything safely.
                            
                            // 3. Show confirmation
                            self.show_confirmation_modal = true;
                        }
                    }
                    ui.add_space(10.0);
                    if !can_flash {
                        ui.label(egui::RichText::new("Complete steps 1 & 2").size(11.0).color(TEXT_GREY));
                    }
                });
            });
    }

    fn render_progress_fullscreen(&mut self, ui: &mut egui::Ui) {
        ui.vertical_centered(|ui| {
            ui.add_space(150.0);
            
            if self.is_verifying {
                let v_progress = *self.verify_progress.lock().unwrap();
                ui.label(egui::RichText::new("Verifying Integrity").size(32.0).color(ACCENT_CYAN).strong());
                ui.add_space(10.0);
                ui.label(egui::RichText::new(format!("{}%", (v_progress * 100.0) as u32)).size(48.0).color(TEXT_WHITE).strong());
                ui.add_space(20.0);
                ui.add_sized(egui::vec2(600.0, 12.0), egui::ProgressBar::new(v_progress).fill(SUCCESS_GREEN).animate(true));
            } else {
                let progress = *self.progress.lock().unwrap();
                ui.label(egui::RichText::new(format!("{}%", (progress * 100.0) as u32)).size(48.0).color(TEXT_WHITE).strong());
                ui.add_space(20.0);
                ui.add_sized(egui::vec2(600.0, 12.0), egui::ProgressBar::new(progress).fill(ACCENT_CYAN).animate(true));
                
                ui.add_space(30.0);
                if let Some(start_time) = self.flash_start_time {
                    let elapsed = start_time.elapsed().as_secs_f32();
                    let bytes_written = *self.bytes_written.lock().unwrap();
                    if elapsed > 0.0 && bytes_written > 0 {
                        let speed_mbps = (bytes_written as f32 / elapsed) / (1024.0 * 1024.0);
                        ui.label(egui::RichText::new(format!("Speed: {:.1} MB/s", speed_mbps)).size(14.0).color(TEXT_GREY));
                        if let Some(total_size) = self.image_size {
                            let remaining = total_size.saturating_sub(bytes_written);
                            if speed_mbps > 0.0 {
                                let eta_secs = (remaining as f32 / (speed_mbps * 1024.0 * 1024.0)) as u64;
                                ui.label(egui::RichText::new(format!("ETA: {}", format_duration(eta_secs))).size(14.0).color(TEXT_GREY));
                            }
                        }
                    }
                }
            }

            ui.add_space(20.0);
            let status = self.status.lock().unwrap().clone();
            ui.label(egui::RichText::new(status).size(12.0).color(TEXT_GREY));
        });
    }

    fn render_device_modal(&mut self, ctx: &egui::Context) {
        let mut close_modal = false;
        egui::Window::new("Select Target USB").open(&mut self.show_device_modal).collapsible(false).resizable(false)
            .anchor(egui::Align2::CENTER_CENTER, egui::vec2(0.0, 0.0)).show(ctx, |ui| {
                ui.set_min_width(600.0);
                if self.devices.is_empty() {
                    ui.label("No removable USB devices found.");
                } else {
                    ui.horizontal(|ui| {
                        ui.label(egui::RichText::new("").size(12.0));
                        ui.add_space(10.0);
                        ui.label(egui::RichText::new("Device").strong().size(12.0));
                        ui.add_space(200.0);
                        ui.label(egui::RichText::new("Size").strong().size(12.0));
                    });
                    ui.separator();
                    let mut selected_idx = None;
                    for (idx, device) in self.devices.iter().enumerate() {
                        let is_selected = self.selected_device == Some(idx);
                        let is_system = device.is_system_disk;
                        
                        let response = ui.horizontal(|ui| {
                            ui.add_enabled_ui(!is_system, |ui| {
                                ui.label(egui::RichText::new(if is_selected { "●" } else { "○" }).size(16.0).color(ACCENT_CYAN));
                                ui.add_space(10.0);
                                ui.label(&device.path);
                                ui.add_space(150.0);
                                ui.label(&device.size);
                                
                                if is_system {
                                    ui.add_space(10.0);
                                    ui.label(egui::RichText::new("(System Disk - Protected)").color(egui::Color32::from_rgb(255, 69, 0)).small());
                                } else if device.mounted {
                                    ui.add_space(10.0);
                                    ui.label(egui::RichText::new("(Mounted)").color(egui::Color32::from_rgb(255, 165, 0)).small());
                                }
                            });
                        });
                        
                        if !is_system && response.response.interact(egui::Sense::click()).clicked() {
                            selected_idx = Some(idx);
                        }
                    }
                    if let Some(idx) = selected_idx {
                        self.selected_device = Some(idx);
                    }
                }
                ui.add_space(20.0);
                ui.horizontal(|ui| {
                    if ui.add(egui::Button::new(egui::RichText::new("Cancel").color(TEXT_GREY))
                        .stroke(egui::Stroke::new(1.0, TEXT_GREY)).fill(egui::Color32::TRANSPARENT)
                        .rounding(20.0).min_size(egui::vec2(120.0, 40.0))).clicked() {
                        close_modal = true;
                    }
                    ui.add_space(10.0);
                    if ui.add_enabled(self.selected_device.is_some(),
                        egui::Button::new(egui::RichText::new("Select").color(TEXT_WHITE))
                        .fill(ACCENT_CYAN).rounding(20.0).min_size(egui::vec2(120.0, 40.0))).clicked() {
                        close_modal = true;
                    }
                });
            });
        if close_modal {
            self.show_device_modal = false;
        }
    }

    fn render_settings_modal(&mut self, ctx: &egui::Context) {
        let mut close_modal = false;
        egui::Window::new("Settings").open(&mut self.show_settings_modal).collapsible(false).resizable(false)
            .anchor(egui::Align2::CENTER_CENTER, egui::vec2(0.0, 0.0)).show(ctx, |ui| {
                ui.set_min_width(400.0);
                ui.checkbox(&mut self.setting_report_errors, "Anonymously report errors");
                ui.add_space(10.0);
                ui.checkbox(&mut self.setting_trim_space, "Trim unallocated space");
                ui.add_space(20.0);
                ui.hyperlink_to("⚡ v0.1.0", "https://github.com/fluxflasher/fluxflasher");
                ui.add_space(20.0);
                ui.vertical_centered(|ui| {
                    if ui.add(egui::Button::new(egui::RichText::new("OK").color(TEXT_WHITE))
                        .fill(ACCENT_CYAN).rounding(20.0).min_size(egui::vec2(150.0, 40.0))).clicked() {
                        close_modal = true;
                    }
                });
            });
        if close_modal {
            self.show_settings_modal = false;
        }
    }

    fn render_completion_modal(&mut self, ctx: &egui::Context) {
        egui::Window::new("Flash Complete").collapsible(false).resizable(false)
            .anchor(egui::Align2::CENTER_CENTER, egui::vec2(0.0, 0.0)).show(ctx, |ui| {
                ui.set_min_width(400.0);
                ui.vertical_centered(|ui| {
                    ui.add_space(20.0);
                    ui.label(egui::RichText::new("✓").size(64.0).color(SUCCESS_GREEN));
                    ui.add_space(15.0);
                    ui.label(egui::RichText::new("Flash Completed Successfully!").size(20.0).color(TEXT_WHITE).strong());
                    ui.add_space(30.0);
                    if ui.add(egui::Button::new(egui::RichText::new("OK").size(16.0).color(TEXT_WHITE))
                        .fill(ACCENT_CYAN).rounding(20.0).min_size(egui::vec2(150.0, 45.0))).clicked() {
                        self.show_completion_modal = false;
                        self.image_path = None;
                        self.selected_device = None;
                    }
                    ui.add_space(10.0);
                });
            });
    }

    fn render_confirmation_modal(&mut self, ctx: &egui::Context) {
        egui::Window::new("Confirm Flash").collapsible(false).resizable(false)
            .anchor(egui::Align2::CENTER_CENTER, egui::vec2(0.0, 0.0)).show(ctx, |ui| {
                ui.set_min_width(450.0);
                ui.vertical_centered(|ui| {
                    ui.add_space(10.0);
                    ui.label(egui::RichText::new("⚠ WARNING: DATA DESTRUCTION").size(20.0).color(egui::Color32::from_rgb(255, 69, 0)).strong());
                    ui.add_space(15.0);
                    
                    let device_name = self.selected_device
                        .and_then(|idx| self.devices.get(idx))
                        .map(|d| d.path.clone())
                        .unwrap_or_else(|| "Unknown".to_string());
                    
                    ui.label(egui::RichText::new("This will permanently erase all data on:").size(14.0).color(TEXT_WHITE));
                    ui.label(egui::RichText::new(&device_name).size(18.0).color(ACCENT_CYAN).strong());
                    
                    ui.add_space(20.0);
                    ui.label(egui::RichText::new("Are you absolutely sure you want to proceed?").size(14.0).color(TEXT_GREY));
                    ui.add_space(25.0);
                    
                    ui.horizontal(|ui| {
                        ui.add_space(70.0);
                        if ui.add(egui::Button::new(egui::RichText::new("Cancel").color(TEXT_GREY))
                            .stroke(egui::Stroke::new(1.0, TEXT_GREY)).fill(egui::Color32::TRANSPARENT)
                            .rounding(20.0).min_size(egui::vec2(120.0, 40.0))).clicked() {
                            self.show_confirmation_modal = false;
                        }
                        ui.add_space(20.0);
                        if ui.add(egui::Button::new(egui::RichText::new("Flash Now!").color(TEXT_WHITE))
                            .fill(egui::Color32::from_rgb(255, 69, 0)).rounding(20.0).min_size(egui::vec2(120.0, 40.0))).clicked() {
                            self.show_confirmation_modal = false;
                            if let (Some(img), Some(dev_idx)) = (self.image_path.clone(), self.selected_device) {
                                if let Some(device) = self.devices.get(dev_idx) {
                                    self.start_flash(img, device.path.clone());
                                }
                            }
                        }
                    });
                    ui.add_space(10.0);
                });
            });
    }

    fn render_error_modal(&mut self, ctx: &egui::Context) {
        egui::Window::new("Error").collapsible(false).resizable(false)
            .anchor(egui::Align2::CENTER_CENTER, egui::vec2(0.0, 0.0)).show(ctx, |ui| {
                ui.set_min_width(400.0);
                ui.vertical_centered(|ui| {
                    ui.add_space(10.0);
                    ui.label(egui::RichText::new("❌").size(48.0));
                    ui.add_space(10.0);
                    ui.label(egui::RichText::new(&self.error_message).size(18.0).color(TEXT_WHITE).strong());
                    ui.add_space(10.0);
                    ui.label(egui::RichText::new(&self.error_details).size(12.0).color(TEXT_GREY));
                    ui.add_space(20.0);
                    if ui.add(egui::Button::new(egui::RichText::new("Dismiss").color(TEXT_WHITE))
                        .fill(ACCENT_CYAN).rounding(20.0).min_size(egui::vec2(150.0, 40.0))).clicked() {
                        self.show_error_modal = false;
                    }
                    ui.add_space(10.0);
                });
            });
    }

    fn render_unmount_prompt(&mut self, ctx: &egui::Context) {
        egui::Window::new("Mounted Partitions Detected").collapsible(false).resizable(false)
            .anchor(egui::Align2::CENTER_CENTER, egui::vec2(0.0, 0.0)).show(ctx, |ui| {
                ui.set_min_width(400.0);
                ui.vertical_centered(|ui| {
                    ui.add_space(10.0);
                    ui.label(egui::RichText::new("The target device has mounted partitions.").size(14.0).color(TEXT_WHITE));
                    ui.label(egui::RichText::new("They must be unmounted before flashing.").size(14.0).color(TEXT_WHITE));
                    ui.add_space(20.0);
                    ui.horizontal(|ui| {
                        ui.add_space(70.0);
                        if ui.add(egui::Button::new(egui::RichText::new("Cancel").color(TEXT_GREY))
                            .stroke(egui::Stroke::new(1.0, TEXT_GREY)).fill(egui::Color32::TRANSPARENT)
                            .rounding(20.0).min_size(egui::vec2(120.0, 40.0))).clicked() {
                            self.show_unmount_prompt = false;
                        }
                        ui.add_space(20.0);
                        if ui.add(egui::Button::new(egui::RichText::new("Unmount All").color(TEXT_WHITE))
                            .fill(ACCENT_CYAN).rounding(20.0).min_size(egui::vec2(120.0, 40.0))).clicked() {
                            self.show_unmount_prompt = false;
                            if let Some(dev_idx) = self.selected_device {
                                let device_path = self.devices[dev_idx].path.clone();
                                let _ = Command::new("pkexec").args(["umount", &device_path]).status();
                                // Refresh devices
                                if let Ok(devices) = list_usb_devices() {
                                    self.devices = devices;
                                }
                            }
                        }
                    });
                    ui.add_space(10.0);
                });
            });
    }

    fn start_flash(&mut self, image: PathBuf, device: String) {
        self.flashing = true;
        self.is_verifying = false;
        self.flash_start_time = Some(Instant::now());
        *self.status.lock().unwrap() = "Initializing...".to_string();
        *self.progress.lock().unwrap() = 0.0;
        *self.bytes_written.lock().unwrap() = 0;
        
        // Find mountpoints for the device
        let mount_points = self.devices.iter()
            .find(|d| d.path == device)
            .map(|d| d.mount_points.clone())
            .unwrap_or_default();

        let progress = self.progress.clone();
        let status = self.status.clone();
        let bytes_written = self.bytes_written.clone();
        let verify_progress = self.verify_progress.clone();
        
        // Arc-clone for closure
        let image_clone = image.clone();
        let device_clone = device.clone();

        thread::spawn(move || {
            // Flash Phase
            match flash_image(&image_clone, &device_clone, progress.clone(), status.clone(), bytes_written.clone(), &mount_points) {
                Ok(_) => {
                    // Verification Phase
                     *status.lock().unwrap() = "Starting verification...".to_string();
                     // We might need to flag to UI that we are verifying
                     
                     match verify_integrity(&image_clone, &device_clone, verify_progress.clone(), status.clone()) {
                         Ok(_) => {
                             *status.lock().unwrap() = "All operations completed successfully!".to_string();
                             *progress.lock().unwrap() = 1.0;
                             *verify_progress.lock().unwrap() = 1.0;
                         }
                         Err(e) => {
                             *status.lock().unwrap() = format!("Verification Error: {}", e);
                         }
                     }
                }
                Err(e) => {
                    *status.lock().unwrap() = format!("Flash Error: {}", e);
                }
            }
        });
    }
}

// Safety: Get the root filesystem device
fn list_usb_devices() -> Result<Vec<UsbDevice>> {
    let output = Command::new("lsblk")
        .arg("-J")
        .arg("-b")
        .arg("-o")
        .arg("NAME,SIZE,RO,TYPE,MOUNTPOINT,RM")
        .output()
        .context("Failed to run lsblk")?;

    let lsblk: LsblkOutput = serde_json::from_slice(&output.stdout)
        .context("Failed to parse lsblk JSON")?;

    let mut devices = Vec::new();

    for device in lsblk.blockdevices {
        // We are interested in 'disk' type which are removable (rm=true) or others if needed
        // But user requirement says: resolve backing disk of / even with LVM/crypt/RAID
        // So we need to identify which disks are system disks first.
        
        let mut mount_points = Vec::new();
        let is_system = check_system_recursive(&device, &mut mount_points);
        
        if device.dev_type == "disk" && device.rm {
             // It's a removable disk, candidate
             let size_display = format_size(device.size);
             
             devices.push(UsbDevice {
                 path: format!("/dev/{}", device.name),
                 size: size_display,
                 size_bytes: device.size,
                 removable: device.rm,
                 mounted: !mount_points.is_empty(),
                 is_system_disk: is_system,
                 mount_points,
             });
        }
    }
    
    Ok(devices)
}

fn check_system_recursive(device: &LsblkDevice, all_mounts: &mut Vec<String>) -> bool {
    let mut is_system = false;
    
    if let Some(mp) = &device.mountpoint {
        all_mounts.push(mp.clone());
        if mp == "/" || mp == "/boot" || mp == "/boot/efi" || mp == "/home" {
            is_system = true;
        }
    }
    
    for child in &device.children {
        if check_system_recursive(child, all_mounts) {
            is_system = true;
        }
    }
    
    is_system
}


fn flash_image(
    image_path: &PathBuf, 
    device_path: &str, 
    progress: Arc<Mutex<f32>>, 
    status: Arc<Mutex<String>>, 
    bytes_written: Arc<Mutex<u64>>,
    mount_points: &[String]
) -> Result<()> {
    // 1. Unmount all partitions
    if !mount_points.is_empty() {
        *status.lock().unwrap() = "Unmounting partitions...".to_string();
        for mp in mount_points {
            let umount_status = Command::new("pkexec")
                .arg("umount")
                .arg(mp)
                .status()
                .context("Failed to execute umount")?;
            
            if !umount_status.success() {
                 return Err(anyhow::anyhow!("Failed to unmount {}", mp));
            }
        }
    }

    // 2. Flash with flock and progress
    *status.lock().unwrap() = "Starting write process...".to_string();
    let image_size = std::fs::metadata(image_path)?.len();
    
    // Construct command: pkexec flock /dev/sdX dd ...
    // We strictly use bytes for seeking/count if needed, but here we just write the whole image
    // status=progress writes to stderr
    let mut child = Command::new("pkexec")
        .arg("flock")
        .arg(device_path)
        .arg("dd")
        .arg(format!("if={}", image_path.display()))
        .arg(format!("of={}", device_path))
        .arg("bs=4M")
        .arg("conv=fsync")
        .arg("status=progress")
        .stdout(Stdio::null())
        .stderr(Stdio::piped())
        .spawn()
        .context("Failed to start dd")?;

    let stderr = child.stderr.take().ok_or_else(|| anyhow::anyhow!("Failed to capture stderr"))?;
    let reader = BufReader::new(stderr);
    
    // Parse progress in a separate thread or just loop? 
    // We need to wait for child, but also read stderr.
    // Since we are in a spawned thread (from main), we can block here.
    
    for line in reader.lines() {
        if let Ok(line) = line {
            // dd status=progress format: "20971520 bytes (21 MB, 20 MiB) copied, ..."
            if let Some(bytes_str) = line.split_whitespace().next() {
                if let Ok(bytes) = bytes_str.parse::<u64>() {
                     *bytes_written.lock().unwrap() = bytes;
                     *progress.lock().unwrap() = (bytes as f32 / image_size as f32).min(0.99);
                }
            }
        }
    }

    let exit_status = child.wait()?;
    if !exit_status.success() {
        return Err(anyhow::anyhow!("Flash process failed (exit code {:?})", exit_status.code()));
    }

    *progress.lock().unwrap() = 1.0;
    *bytes_written.lock().unwrap() = image_size;
    Ok(())
}

fn verify_integrity(
    image_path: &PathBuf,
    device_path: &str,
    progress: Arc<Mutex<f32>>,
    status: Arc<Mutex<String>>
) -> Result<()> {
    *status.lock().unwrap() = "Verifying: Hashing source image...".to_string();
    *progress.lock().unwrap() = 0.0;
    
    let mut file = File::open(image_path)?;
    let total_size = file.metadata()?.len();
    let mut hasher = Sha256::new();
    let mut buffer = [0u8; 1024 * 1024]; // 1MB buffer
    let mut read_so_far = 0;

    loop {
        let n = file.read(&mut buffer)?;
        if n == 0 { break; }
        hasher.update(&buffer[..n]);
        read_so_far += n as u64;
         *progress.lock().unwrap() = (read_so_far as f32 / total_size as f32) * 0.5;
    }
    let expected_hash = hasher.finalize();

    *status.lock().unwrap() = "Verifying: Hashing device content...".to_string();
    
    // Read from device (requires root usually, so pkexec dd again? or just open if we have permission?)
    // Usually raw device read requires root.
    // We can use pkexec dd to stdout and pipe to us.
    
    let mut child = Command::new("pkexec")
        .arg("dd")
        .arg(format!("if={}", device_path))
        .arg(format!("count={}", total_size)) // Read exactly image size
        .arg("iflag=count_bytes")
        .arg("bs=4M")
        .arg("status=none")
        .stdout(Stdio::piped())
        .spawn()?;

    let stdout = child.stdout.take().ok_or_else(|| anyhow::anyhow!("Failed to open device stream"))?;
    let mut reader = BufReader::new(stdout);
    let mut dev_hasher = Sha256::new();
    let mut dev_read_so_far = 0;
    
    loop {
        let n = reader.read(&mut buffer)?;
        if n == 0 { break; }
        dev_hasher.update(&buffer[..n]);
        dev_read_so_far += n as u64;
        // Map 0.5 -> 1.0
        *progress.lock().unwrap() = 0.5 + ((dev_read_so_far as f32 / total_size as f32) * 0.5);
    }
    
    let _ = child.wait(); // cleanup
    
    let actual_hash = dev_hasher.finalize();
    
    if expected_hash != actual_hash {
        return Err(anyhow::anyhow!("Verification failed: Hash mismatch!"));
    }

    *status.lock().unwrap() = "Verification Successful!".to_string();
    *progress.lock().unwrap() = 1.0;
    Ok(())
}

fn format_size(bytes: u64) -> String {
    const GB: u64 = 1024 * 1024 * 1024;
    const MB: u64 = 1024 * 1024;
    if bytes >= GB {
        format!("{:.2} GB", bytes as f64 / GB as f64)
    } else if bytes >= MB {
        format!("{:.2} MB", bytes as f64 / MB as f64)
    } else {
        format!("{} bytes", bytes)
    }
}

fn format_duration(secs: u64) -> String {
    let hours = secs / 3600;
    let minutes = (secs % 3600) / 60;
    let seconds = secs % 60;
    if hours > 0 {
        format!("{}h {}m", hours, minutes)
    } else if minutes > 0 {
        format!("{}m {}s", minutes, seconds)
    } else {
        format!("{}s", seconds)
    }
}
